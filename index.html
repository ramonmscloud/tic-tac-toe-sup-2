<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe - Canvas + Supabase V1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Gris claro de Tailwind */
        }
        .player-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid transparent;
            transition: border-color 0.3s;
            background-color: #e5e7eb;
        }
        .player-image.active {
            border-color: #3b82f6;
        }
        .winner-image {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
            vertical-align: middle;
            display: inline-block;
        }
        .hidden {
            display: none;
        }
        #tic-tac-toe-canvas {
            cursor: pointer;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gradient-to-br from-blue-100 to-purple-100">

    <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 mb-6 text-center">Tic Tac Toe - Remoto (V1 Canvas)</h1>

    <div id="auth-section" class="w-full max-w-lg p-6 bg-white rounded-lg shadow-md mb-6 text-center">
        <h2 class="text-xl font-semibold text-gray-700 mb-4">Autenticación y Partida</h2>
        <div id="user-status" class="mb-2">No autenticado</div>
        <input type="email" id="email-input" placeholder="Tu correo electrónico" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <input type="password" id="password-input" placeholder="Contraseña" type="password" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <div class="flex space-x-2 mb-4">
            <button id="signup-button" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md">Registrarse</button>
            <button id="login-button" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md">Iniciar Sesión</button>
            <button id="logout-button" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md hidden">Cerrar Sesión</button>
        </div>
        <hr class="my-4">

        <input type="text" id="game-id-input" placeholder="ID de Partida para unirse/cargar" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <button id="create-load-game-button" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 disabled:opacity-50" disabled>
            Crear Nueva Partida / Unirse por ID
        </button>
        <p id="game-link-message" class="mt-2 text-sm text-gray-600"></p>
        
        <hr class="my-4">
        <h3 class="text-lg font-semibold text-gray-700 mb-2">Partidas Abiertas (Esperando Oponente):</h3>
        <div id="open-games-list" class="max-h-48 overflow-y-auto border border-gray-200 rounded-md p-2 text-left">
            <p id="no-open-games" class="text-gray-500 text-center">No hay partidas abiertas actualmente.</p>
            <!-- Las partidas se listarán aquí dinámicamente -->
        </div>
    </div>

    <div id="game-section" class="hidden w-full max-w-md flex flex-col items-center">
        <div id="player-turn" class="flex items-center justify-center space-x-4 mb-4 p-3 bg-white rounded-lg shadow">
            <img id="current-player-image" src="" alt="Imagen del jugador actual" class="player-image active">
            <p class="text-lg font-semibold text-gray-700">Turno de: <span id="current-player-name" class="font-bold"></span></p>
        </div>

        <canvas id="tic-tac-toe-canvas" width="306" height="306" class="mb-4 bg-white rounded-lg shadow-inner border-2 border-gray-300"></canvas>

        <div id="status-message-container" class="flex items-center justify-center text-xl font-semibold text-center text-gray-800 mb-4 h-8">
             <span id="status-message"></span>
        </div>

        <div class="flex space-x-4">
             <button id="reset-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200">
                 Reiniciar Partida
             </button>
             <button id="change-players-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200">
                 Nueva Partida / Salir
             </button>
        </div>
    </div>

<script>
    // --- Supabase ---
    const SUPABASE_URL = 'https://gjxhppuobvjuypsxqhah.supabase.co'; // <<<========= REEMPLAZA ESTO
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqeGhwcHVvYnZqdXlwc3hxaGFoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0MzcxNzIsImV4cCI6MjA2MjAxMzE3Mn0.Rk1xe9CCyDccS4ueN-AI6Glv05xSK7hS2LXtxclLXtU'; // <<<===== REEMPLAZA ESTO
    let supabaseClient = null;
    let currentUser = null;
    let currentGameId = null;
    let currentGameData = null;
    let gameRealtimeChannel = null;


    // --- DOM Elements ---
    const authSection = document.getElementById('auth-section');
    const userStatusElement = document.getElementById('user-status');
    const emailInput = document.getElementById('email-input');
    const passwordInput = document.getElementById('password-input');
    const signupButton = document.getElementById('signup-button');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const gameIdInput = document.getElementById('game-id-input');
    const createLoadGameButton = document.getElementById('create-load-game-button');
    const gameLinkMessage = document.getElementById('game-link-message');
    const openGamesListElement = document.getElementById('open-games-list');
    let noOpenGamesMessage = document.getElementById('no-open-games'); // Can be re-assigned

    const gameSection = document.getElementById('game-section');
    const playerTurnElement = document.getElementById('player-turn');
    const currentPlayerImage = document.getElementById('current-player-image');
    const currentPlayerName = document.getElementById('current-player-name');
    const statusMessageContainer = document.getElementById('status-message-container');
    let statusMessageSpan = document.getElementById('status-message');
    const resetButton = document.getElementById('reset-button');
    const changePlayersButton = document.getElementById('change-players-button');

    // --- Canvas Variables ---
    let canvas = null;
    let ctx = null;
    const CANVAS_WIDTH = 306;
    const CANVAS_HEIGHT = 306;
    const NUM_CELLS_PER_ROW = 3;
    const CELL_SIZE = 100;
    const LINE_THICKNESS = 2;
    const GRID_COLOR = '#e5e7eb';
    const SYMBOL_COLOR_X = '#3b82f6';
    const SYMBOL_COLOR_O = '#ef4444';
    const WINNING_LINE_COLOR = '#10b981';
    const WINNING_LINE_THICKNESS = 5;

    // --- Game State ---
    let board = ['', '', '', '', '', '', '', '', ''];
    let currentPlayerIndex = 0;
    let isGameOver = false;
    const DEFAULT_IMAGE_URL = 'https://placehold.co/60x60/cccccc/ffffff?text=?';
    const winningCombinations = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];

    // --- Supabase Functions ---
    function initializeSupabase() {
        if (!SUPABASE_URL || SUPABASE_URL === 'TU_SUPABASE_URL' || !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY === 'TU_SUPABASE_ANON_KEY') {
            console.error("Supabase URL o Anon Key no configuradas.");
            alert("Error de configuración: Faltan las credenciales de Supabase.");
            return false;
        }
        try {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            return true;
        } catch (error) {
            console.error("Error inicializando Supabase Client:", error);
            alert("Error crítico inicializando Supabase. Revisa la consola.");
            return false;
        }
    }

    async function checkUserSession() {
        if (!supabaseClient) return;
        const { data: { session } } = await supabaseClient.auth.getSession();
        if (session) {
            currentUser = session.user;
            userStatusElement.textContent = `Autenticado: ${currentUser.email.split('@')[0]}`;
            emailInput.classList.add('hidden');
            passwordInput.classList.add('hidden');
            signupButton.classList.add('hidden');
            loginButton.classList.add('hidden');
            logoutButton.classList.remove('hidden');
            createLoadGameButton.disabled = false;
            await fetchAndDisplayOpenGames(); // Actualizar lista de partidas abiertas
        } else {
            currentUser = null;
            userStatusElement.textContent = 'No autenticado';
            emailInput.classList.remove('hidden');
            passwordInput.classList.remove('hidden');
            signupButton.classList.remove('hidden');
            loginButton.classList.remove('hidden');
            logoutButton.classList.add('hidden');
            createLoadGameButton.disabled = true;
            openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
            noOpenGamesMessage = document.getElementById('no-open-games');
            if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
            showAuthSection();
        }
    }

    async function handleSignUp() {
        if (!supabaseClient) return;
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!email || !password) { alert("Email y contraseña son requeridos."); return; }
        const { data, error } = await supabaseClient.auth.signUp({ email, password });
        if (error) alert(`Error registro: ${error.message}`);
        else alert('Registro exitoso. Revisa tu email para confirmar y luego inicia sesión.');
    }

    async function handleSignIn() {
        if (!supabaseClient) return;
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!email || !password) { alert("Email y contraseña son requeridos."); return; }
        const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
        if (error) alert(`Error inicio de sesión: ${error.message}`);
        else {
            // currentUser se setea en onAuthStateChange o checkUserSession
            // await checkUserSession(); // Ya se llama por onAuthStateChange
            const urlParams = new URLSearchParams(window.location.search);
            const gameIdFromUrl = urlParams.get('game');
            if (gameIdFromUrl && createLoadGameButton && !createLoadGameButton.disabled) {
                gameIdInput.value = gameIdFromUrl;
                await loadOrCreateGame();
            }
        }
    }
    async function handleSignOut() {
        if (!supabaseClient) return;
        const { error } = await supabaseClient.auth.signOut();
        if (error) alert(`Error cerrando sesión: ${error.message}`);
        // currentUser se setea en onAuthStateChange o checkUserSession
        // await checkUserSession(); // Ya se llama por onAuthStateChange
        // showAuthSection(); // Ya se llama por onAuthStateChange -> checkUserSession
    }

    async function createNewGameOnSupabase() {
        if (!supabaseClient || !currentUser) return null;
        const initialPlayer = {
            user_id: currentUser.id,
            name: currentUser.email.split('@')[0] || `JugadorX`,
            symbol: 'X',
            imageUrl: DEFAULT_IMAGE_URL
        };
        const newGame = {
            board: ['', '', '', '', '', '', '', '', ''],
            current_player_index: 0,
            players: [initialPlayer],
            is_game_over: false,
            winner_index: null,
            winning_combination: null,
        };
        const { data, error } = await supabaseClient.from('games').insert([newGame]).select().single();
        if (error) { console.error('Error creando partida:', error); alert(`Error creando partida: ${error.message}`); return null; }
        return data;
    }

    async function fetchGameFromSupabase(gameId) {
        if (!supabaseClient) return null;
        const { data, error } = await supabaseClient.from('games').select('*').eq('id', gameId).single();
        if (error) {
            if (error.code !== 'PGRST116') alert(`Error cargando partida: ${error.message}`);
            return null;
        }
        return data;
    }

    async function updateGameOnSupabase(gameId, updates) {
        if (!supabaseClient || !gameId) return null;
        const { data, error } = await supabaseClient.from('games').update(updates).eq('id', gameId).select().single();
        if (error) { console.error('Error actualizando partida:', error); alert(`Error actualizando: ${error.message}`); return null; }
        return data;
    }

    async function fetchAndDisplayOpenGames() {
        if (!supabaseClient || !currentUser) {
            openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
            noOpenGamesMessage = document.getElementById('no-open-games');
            if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
            return;
        }

        // Usaremos la versión con filtrado en cliente por simplicidad, pero RPC es mejor para producción.
        // Si tienes la función RPC 'get_open_games' creada en tu base de datos:
        // const { data: openGames, error } = await supabaseClient.rpc('get_open_games', { current_user_id: currentUser.id });
        // Si no, filtramos en cliente:
        const { data: games, error } = await supabaseClient
            .from('games')
            .select('id, players, created_at')
            .filter('is_game_over', 'eq', false)
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Error fetching games:', error);
            openGamesListElement.innerHTML = '<p class="text-red-500 text-center">Error al cargar partidas.</p>';
            noOpenGamesMessage = null;
            return;
        }

        const openGames = games.filter(game =>
            game.players &&
            game.players.length === 1 &&
            game.players[0].user_id !== currentUser.id
        );

        openGamesListElement.innerHTML = ''; 

        if (openGames.length === 0) {
            const p = document.createElement('p');
            p.id = 'no-open-games';
            p.className = 'text-gray-500 text-center';
            p.textContent = 'No hay partidas abiertas para unirse.';
            openGamesListElement.appendChild(p);
            noOpenGamesMessage = p;
        } else {
            if (noOpenGamesMessage) noOpenGamesMessage.classList.add('hidden');
            noOpenGamesMessage = null; // Ya no existe el mensaje "no hay partidas"
            const ul = document.createElement('ul');
            ul.className = 'space-y-2';
            openGames.forEach(game => {
                const li = document.createElement('li');
                li.className = 'p-2 border-b border-gray-100 hover:bg-gray-50 rounded-md flex justify-between items-center cursor-pointer';
                li.onclick = () => {
                    gameIdInput.value = game.id;
                    loadOrCreateGame();
                };

                const gameInfo = document.createElement('span');
                const creatorName = game.players[0]?.name || 'Jugador Anónimo';
                const gameDate = new Date(game.created_at).toLocaleDateString('es-ES', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                gameInfo.textContent = `Partida de ${creatorName} (Creada: ${gameDate})`;
                gameInfo.className = "text-sm text-gray-700";

                const joinButton = document.createElement('button');
                joinButton.textContent = 'Unirse';
                joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white text-xs font-semibold py-1 px-3 rounded-md pointer-events-none'; // pointer-events-none porque el li es clickable

                li.appendChild(gameInfo);
                li.appendChild(joinButton); // Botón es más visual
                ul.appendChild(li);
            });
            openGamesListElement.appendChild(ul);
        }
    }


    // --- Canvas Drawing Functions ---
    function initializeCanvasAndBoard() {
        canvas = document.getElementById('tic-tac-toe-canvas');
        if (!canvas) { console.error("Canvas element not found!"); return false; }
        ctx = canvas.getContext('2d');
        if (!ctx) { console.error("2D context not available!"); return false; }
        
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        drawBoardGrid();
        drawSymbols();
        if (isGameOver && currentGameData && currentGameData.winning_combination) {
            drawWinningLine(currentGameData.winning_combination);
        }
        canvas.removeEventListener('click', handleCanvasClick);
        canvas.addEventListener('click', handleCanvasClick);
        return true;
    }
    
    function getCellOffset(index) {
        const row = Math.floor(index / NUM_CELLS_PER_ROW);
        const col = index % NUM_CELLS_PER_ROW;
        const x = col * (CELL_SIZE + LINE_THICKNESS);
        const y = row * (CELL_SIZE + LINE_THICKNESS);
        return { x, y };
    }

    function drawBoardGrid() {
        if (!ctx) return;
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.strokeStyle = GRID_COLOR;
        ctx.lineWidth = LINE_THICKNESS;

        for (let i = 1; i < NUM_CELLS_PER_ROW; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2, 0);
            ctx.lineTo(i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2, CANVAS_HEIGHT);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2);
            ctx.lineTo(CANVAS_WIDTH, i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2);
            ctx.stroke();
        }
    }

    function drawSymbols() {
        if (!ctx || !board) return;
        const symbolPadding = CELL_SIZE * 0.2;

        for (let i = 0; i < board.length; i++) {
            const symbol = board[i];
            if (symbol === '') continue;

            const { x: cellX, y: cellY } = getCellOffset(i);
            
            ctx.lineWidth = CELL_SIZE * 0.08;
            ctx.lineCap = 'round';

            if (symbol === 'X') {
                ctx.strokeStyle = SYMBOL_COLOR_X;
                ctx.beginPath();
                ctx.moveTo(cellX + symbolPadding, cellY + symbolPadding);
                ctx.lineTo(cellX + CELL_SIZE - symbolPadding, cellY + CELL_SIZE - symbolPadding);
                ctx.moveTo(cellX + CELL_SIZE - symbolPadding, cellY + symbolPadding);
                ctx.lineTo(cellX + symbolPadding, cellY + CELL_SIZE - symbolPadding);
                ctx.stroke();
            } else if (symbol === 'O') {
                ctx.strokeStyle = SYMBOL_COLOR_O;
                ctx.beginPath();
                ctx.arc(
                    cellX + CELL_SIZE / 2,
                    cellY + CELL_SIZE / 2,
                    CELL_SIZE / 2 - symbolPadding,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
            }
        }
    }

    function drawWinningLine(combination) {
        if (!ctx || !combination || combination.length !== 3) return;

        const { x: startXOffset, y: startYOffset } = getCellOffset(combination[0]);
        const { x: endXOffset, y: endYOffset } = getCellOffset(combination[2]);
        
        const halfCell = CELL_SIZE / 2;

        ctx.strokeStyle = WINNING_LINE_COLOR;
        ctx.lineWidth = WINNING_LINE_THICKNESS;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(startXOffset + halfCell, startYOffset + halfCell);
        ctx.lineTo(endXOffset + halfCell, endYOffset + halfCell);
        ctx.stroke();
    }

    // --- Game Logic Functions ---
    function subscribeToGameUpdates(gameId) {
        if (gameRealtimeChannel) {
            gameRealtimeChannel.unsubscribe();
            gameRealtimeChannel = null;
        }
        if (!supabaseClient || !gameId) return;

        console.log(`Subscribing to game updates for game ID: ${gameId}`);
        gameRealtimeChannel = supabaseClient
            .channel(`game-${gameId}`)
            .on(
                'postgres_changes',
                { event: 'UPDATE', schema: 'public', table: 'games', filter: `id=eq.${gameId}` },
                (payload) => {
                    console.log('Game update received via realtime:', payload);
                    const updatedGame = payload.new;
                    if (updatedGame && updatedGame.id === currentGameId) {
                        // Solo actualiza si el juego actual es el que recibió la actualización
                        // y si el cambio no fue originado por el jugador actual (para evitar doble procesamiento)
                        // Esto último es difícil de determinar sin más info en el payload,
                        // pero la actualización de estado debería ser idempotente.
                        console.log('Applying real-time update to current game data.');
                        initializeAndDisplayGame(updatedGame);
                    }
                }
            )
            .subscribe((status, err) => {
                if (status === 'SUBSCRIBED') {
                    console.log(`Successfully subscribed to game-${gameId}!`);
                }
                if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                    console.error(`Realtime subscription error on game-${gameId}:`, status, err);
                }
                if (err) {
                    console.error('Realtime subscription failed:', err);
                }
            });
    }

    function unsubscribeFromGameUpdates() {
        if (gameRealtimeChannel) {
            console.log("Unsubscribing from game updates.");
            supabaseClient.removeChannel(gameRealtimeChannel);
            gameRealtimeChannel = null;
        }
    }


    async function initializeAndDisplayGame(gameData) {
        if (!gameData) {
            alert("No se pudieron obtener los datos de la partida.");
            showAuthSection();
            return;
        }

        currentGameId = gameData.id;
        currentGameData = gameData; // Actualiza con los datos más recientes
        board = [...gameData.board];
        currentPlayerIndex = gameData.current_player_index;
        isGameOver = gameData.is_game_over;

        authSection.classList.add('hidden');
        gameSection.classList.remove('hidden');

        statusMessageContainer.innerHTML = '<span id="status-message"></span>';
        statusMessageSpan = document.getElementById('status-message');

        if (!initializeCanvasAndBoard()) return;

        if (isGameOver) {
            displayEndGameMessage();
            unsubscribeFromGameUpdates(); // Ya no necesitamos actualizaciones si el juego terminó
        } else {
            updatePlayerTurnDisplay();
            subscribeToGameUpdates(currentGameId); // Suscribirse a actualizaciones para esta partida
        }

        if (currentGameId) {
             gameLinkMessage.textContent = `ID Partida: ${currentGameId}. Comparte este ID o el enlace: ${window.location.origin}${window.location.pathname}?game=${currentGameId}`;
        }
    }

    async function handleCanvasClick(event) {
        if (isGameOver || !currentGameData || !currentUser || !ctx) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;

        let clickedCol = -1, clickedRow = -1;
        for (let c = 0; c < NUM_CELLS_PER_ROW; c++) {
            const cellStartX = c * (CELL_SIZE + LINE_THICKNESS);
            if (x >= cellStartX && x < cellStartX + CELL_SIZE) {
                clickedCol = c;
                break;
            }
        }
        for (let r = 0; r < NUM_CELLS_PER_ROW; r++) {
            const cellStartY = r * (CELL_SIZE + LINE_THICKNESS);
            if (y >= cellStartY && y < cellStartY + CELL_SIZE) {
                clickedRow = r;
                break;
            }
        }
        
        if (clickedCol === -1 || clickedRow === -1) return;

        const cellIndex = clickedRow * NUM_CELLS_PER_ROW + clickedCol;

        const currentPlayerInGame = currentGameData.players[currentGameData.current_player_index];
        if (!currentPlayerInGame || currentPlayerInGame.user_id !== currentUser.id) {
            alert("No es tu turno o no eres un jugador activo en esta partida.");
            return;
        }
        // Esta condición puede ser redundante si la lógica de turnos es correcta
        // if (currentGameData.players.length < 2 && currentPlayerInGame.symbol === 'X' && currentGameData.current_player_index === 1) {
        //      alert("Esperando al jugador O.");
        //      return;
        // }
         if (currentGameData.players.length < 2 && currentUser.id !== currentGameData.players[0].user_id) {
             // Esto es para el caso donde P2 intenta jugar antes de que su unión sea confirmada y el turno sea formalmente de P1.
             // Sin embargo, la lógica de current_player_index y user_id debería cubrir esto.
             alert("Esperando que se una el segundo jugador o que la partida se actualice.");
             return;
         }


        if (board[cellIndex] !== '') return;

        const symbolToPlace = currentPlayerInGame.symbol;
        // Optimistic update localmente primero
        board[cellIndex] = symbolToPlace;
        drawSymbols(); 

        let gameEnded = false;
        let newWinnerIndex = null;
        let newWinningCombination = null;

        if (checkWin(symbolToPlace)) {
            isGameOver = true; // Set local state first
            gameEnded = true;
            newWinnerIndex = currentGameData.current_player_index;
            winningCombinations.forEach(combination => {
                if (combination.every(index => board[index] === symbolToPlace)) {
                    newWinningCombination = combination; // Guardar combinación ganadora
                }
            });
            if(newWinningCombination) drawWinningLine(newWinningCombination); // Dibujar línea inmediatamente
        } else if (board.every(cell => cell !== '')) {
            isGameOver = true; // Set local state first
            gameEnded = true;
        }

        const nextPlayerIndex = gameEnded ? currentGameData.current_player_index : (1 - currentGameData.current_player_index);

        const updates = {
            board: [...board], // Enviar una copia del tablero actualizado
            current_player_index: nextPlayerIndex,
            is_game_over: isGameOver, // Enviar el estado de finalización
            winner_index: newWinnerIndex,
            winning_combination: newWinningCombination,
        };

        // Actualizar Supabase. La suscripción realtime se encargará de actualizar para el otro jugador.
        // Y también para este jugador, lo que forzará una resincronización (initializeAndDisplayGame).
        const updatedGame = await updateGameOnSupabase(currentGameId, updates);
        if (updatedGame) {
            // No es estrictamente necesario actualizar aquí si confías en la suscripción realtime
            // pero puede ser bueno para la respuesta inmediata del jugador actual.
            // initializeAndDisplayGame(updatedGame); // Esto ya se hará por la suscripción realtime si está activa
            // Para evitar doble renderizado, podemos solo actualizar el estado local si no hay realtime
            if (!gameRealtimeChannel) { // Si no hay realtime, actualiza manualmente
                 currentGameData = updatedGame;
                 board = [...updatedGame.board];
                 currentPlayerIndex = updatedGame.current_player_index;
                 isGameOver = updatedGame.is_game_over;

                 if (isGameOver) {
                     displayEndGameMessage();
                 } else {
                     updatePlayerTurnDisplay();
                 }
            }
        } else {
            alert("Error guardando el movimiento. Intentando revertir.");
            // Revertir el movimiento local si Supabase falló
            board[cellIndex] = ''; 
            isGameOver = false; // Revertir estado local
            // Redibujar para quitar el símbolo y la línea ganadora si se dibujó
            drawBoardGrid(); 
            drawSymbols();
            updatePlayerTurnDisplay(); // Volver al estado anterior del turno
        }
    }
    
    function updatePlayerTurnDisplay() {
        if (!currentGameData || currentGameData.players.length === 0 || isGameOver) {
            playerTurnElement.classList.add('hidden');
            return;
        }
        playerTurnElement.classList.remove('hidden');
        // Asegurarse de que current_player_index es válido
        if (currentGameData.current_player_index < 0 || currentGameData.current_player_index >= currentGameData.players.length) {
             console.warn("Índice de jugador actual inválido:", currentGameData.current_player_index, "Jugadores:", currentGameData.players.length);
             // Podrías intentar mostrar un mensaje genérico o el del primer jugador como fallback
             if (currentGameData.players.length > 0) {
                currentPlayerIndex = 0; // Fallback, aunque esto indica un problema de estado
             } else {
                currentPlayerName.textContent = "Esperando jugadores...";
                currentPlayerImage.src = DEFAULT_IMAGE_URL;
                return;
             }
        }

        const playerInfo = currentGameData.players[currentPlayerIndex]; // Usa el currentPlayerIndex local sincronizado
        if (!playerInfo) {
            currentPlayerName.textContent = "Desconocido";
            currentPlayerImage.src = DEFAULT_IMAGE_URL;
            return;
        }
        currentPlayerName.textContent = playerInfo.name || `Jugador ${playerInfo.symbol}`;
        currentPlayerImage.src = playerInfo.imageUrl || DEFAULT_IMAGE_URL;
        currentPlayerImage.alt = `Imagen de ${playerInfo.name || 'Jugador'}`;
        currentPlayerImage.onerror = function() { this.src = DEFAULT_IMAGE_URL; };
        document.querySelectorAll('.player-image.active').forEach(img => img.classList.remove('active'));
        currentPlayerImage.classList.add('active');
    }

    function displayEndGameMessage() {
        statusMessageContainer.innerHTML = '';
        statusMessageSpan = document.createElement('span');
        statusMessageContainer.appendChild(statusMessageSpan);

        playerTurnElement.classList.add('hidden');

        if (currentGameData && currentGameData.is_game_over) {
            // Dibuja la línea ganadora si no se dibujó antes (por si la data vino de realtime)
            if (currentGameData.winning_combination) {
                 drawWinningLine(currentGameData.winning_combination);
            }

            if (currentGameData.winner_index !== null && currentGameData.winner_index >=0 && currentGameData.winner_index < currentGameData.players.length && currentGameData.players[currentGameData.winner_index]) {
                const winner = currentGameData.players[currentGameData.winner_index];
                const winnerImg = document.createElement('img');
                winnerImg.src = winner.imageUrl || DEFAULT_IMAGE_URL;
                winnerImg.alt = `Icono de ${winner.name}`;
                winnerImg.classList.add('winner-image');
                statusMessageContainer.insertBefore(winnerImg, statusMessageSpan);
                statusMessageSpan.textContent = `¡${winner.name} (${winner.symbol}) ha ganado!`;
            } else {
                statusMessageSpan.textContent = '¡Es un empate!';
            }
        }
    }

    function checkWin(symbol) {
        return winningCombinations.some(combination => {
            return combination.every(index => board[index] === symbol);
        });
    }

    async function resetGame() { // "Reset" ahora significa recargar desde el servidor
        if (currentGameId) {
            alert("Recargando el estado actual de la partida desde el servidor.");
            const gameData = await fetchGameFromSupabase(currentGameId);
            if (gameData) {
                 initializeAndDisplayGame(gameData); // Esto también se suscribirá de nuevo
            } else {
                alert("No se pudo recargar la partida. Volviendo a la selección.");
                showAuthSection();
            }
        } else {
            showAuthSection();
        }
    }

    function showAuthSection() {
        unsubscribeFromGameUpdates(); // Asegurarse de desuscribir al salir de una partida
        authSection.classList.remove('hidden');
        gameSection.classList.add('hidden');
        gameLinkMessage.textContent = '';
        gameIdInput.value = ''; // Limpiar input de ID
        currentGameId = null;
        currentGameData = null;
        // La lista de partidas abiertas se actualizará por checkUserSession o el callback de onAuthStateChange
        if (currentUser) {
            fetchAndDisplayOpenGames();
        } else {
             openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
             noOpenGamesMessage = document.getElementById('no-open-games');
             if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
        }
    }

    async function loadOrCreateGame() {
        console.log("loadOrCreateGame triggered. Game ID input:", gameIdInput.value);
        if (!currentUser) {
            alert("Debes estar autenticado para crear o unirte a una partida.");
            return;
        }

        const gameIdToLoad = gameIdInput.value.trim();
        if (gameIdToLoad) {
            const gameData = await fetchGameFromSupabase(gameIdToLoad);
            if (gameData) {
                if (gameData.is_game_over) {
                    alert("Esta partida ya ha terminado. Mostrando resultado.");
                    initializeAndDisplayGame(gameData);
                    return;
                }
                // Verificar si el usuario ya es parte del juego
                const isCurrentUserAPlayer = gameData.players.some(p => p.user_id === currentUser.id);

                if (isCurrentUserAPlayer) {
                    // El usuario ya es un jugador, cargar la partida
                    initializeAndDisplayGame(gameData);
                } else if (gameData.players.length === 1) {
                    // Hay un solo jugador y no es el actual, unirse como jugador 2
                    const player2 = {
                        user_id: currentUser.id,
                        name: currentUser.email.split('@')[0] || `JugadorO`,
                        symbol: 'O',
                        imageUrl: DEFAULT_IMAGE_URL
                    };
                    const updatedPlayers = [...gameData.players, player2];
                    // El turno debe ser del jugador 1 (índice 0) al iniciar.
                    // Si ya había un movimiento del jugador 1, current_player_index podría ser 1.
                    // Lo dejamos como está en gameData, la lógica de turnos debe manejarlo.
                    const updates = { players: updatedPlayers, current_player_index: gameData.current_player_index };
                    const updatedGame = await updateGameOnSupabase(gameData.id, updates);
                    if (updatedGame) {
                        initializeAndDisplayGame(updatedGame);
                    } else {
                        alert("No se pudo unir a la partida como jugador 2.");
                    }
                } else if (gameData.players.length >= 2) {
                    alert("Esta partida ya está llena. Puedes verla como espectador.");
                    // Aquí podrías implementar un modo espectador si lo deseas
                    initializeAndDisplayGame(gameData); // Carga como espectador
                }
            } else {
                alert(`No se encontró partida con ID: ${gameIdToLoad}. Puedes crear una nueva.`);
                gameIdInput.value = '';
            }
        } else { // Crear nueva partida
            const newGame = await createNewGameOnSupabase();
            if (newGame) {
                initializeAndDisplayGame(newGame);
                gameIdInput.value = newGame.id; // Opcional: mostrar ID
                await fetchAndDisplayOpenGames(); // Actualizar lista de partidas para otros
            }
        }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        if (!initializeSupabase()) {
            console.error("Fallo en la inicialización de Supabase. Funcionalidad limitada.");
            return;
        }
        
        // checkUserSession se llamará desde onAuthStateChange la primera vez
        // y también maneja la carga desde URL si el usuario ya está autenticado

        if (signupButton) signupButton.addEventListener('click', handleSignUp);
        if (loginButton) loginButton.addEventListener('click', handleSignIn);
        if (logoutButton) logoutButton.addEventListener('click', handleSignOut);
        if (createLoadGameButton) createLoadGameButton.addEventListener('click', loadOrCreateGame);
        if (resetButton) resetButton.addEventListener('click', resetGame);
        if (changePlayersButton) changePlayersButton.addEventListener('click', showAuthSection);

        const urlParams = new URLSearchParams(window.location.search);
        const gameIdFromUrl = urlParams.get('game');
        if (gameIdFromUrl) {
            gameIdInput.value = gameIdFromUrl;
        }

        supabaseClient.auth.onAuthStateChange(async (event, session) => {
            console.log("Auth state changed:", event, session ? "Session active" : "No session");
            await checkUserSession(); // Revalida la sesión y actualiza la UI, incluyendo lista de partidas

            if (event === "SIGNED_IN" && session) {
                const urlParamsOnSign = new URLSearchParams(window.location.search);
                const gameIdFromUrlOnSignIn = urlParamsOnSign.get('game');
                if (gameIdFromUrlOnSignIn && !currentGameId && createLoadGameButton && !createLoadGameButton.disabled) {
                    console.log("Intentando cargar partida desde URL tras SIGNED_IN...");
                    // gameIdInput.value ya debería estar seteado si vino de la URL
                    await loadOrCreateGame();
                }
            } else if (event === "SIGNED_OUT") {
                // showAuthSection ya se llama dentro de checkUserSession cuando no hay sesión
            }
        });
    });
</script>

</body>
</html>