<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe - Canvas + Supabase V1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Gris claro de Tailwind */
        }
        .player-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid transparent;
            transition: border-color 0.3s;
            background-color: #e5e7eb;
        }
        .player-image.active {
            border-color: #3b82f6;
        }
        .winner-image {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
            vertical-align: middle;
            display: inline-block;
        }
        .hidden {
            display: none;
        }
        #tic-tac-toe-canvas {
            cursor: pointer;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gradient-to-br from-blue-100 to-purple-100">

    <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 mb-6 text-center">Tic Tac Toe - Remoto (V1 Canvas)</h1>

    <div id="auth-section" class="w-full max-w-lg p-6 bg-white rounded-lg shadow-md mb-6 text-center">
        <h2 class="text-xl font-semibold text-gray-700 mb-4">Autenticación y Partida</h2>
        <div id="user-status" class="mb-2">No autenticado</div>
        <input type="email" id="email-input" placeholder="Tu correo electrónico" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <input type="password" id="password-input" placeholder="Contraseña" type="password" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <div class="flex space-x-2 mb-4">
            <button id="signup-button" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md">Registrarse</button>
            <button id="login-button" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md">Iniciar Sesión</button>
            <button id="logout-button" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md hidden">Cerrar Sesión</button>
        </div>
        <hr class="my-4">

        <input type="text" id="game-id-input" placeholder="ID de Partida para unirse/cargar" class="border border-gray-300 p-2 rounded-md w-full mb-2">
        <button id="create-load-game-button" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 disabled:opacity-50" disabled>
            Crear Nueva Partida / Unirse por ID
        </button>
        <p id="game-link-message" class="mt-2 text-sm text-gray-600"></p>
        
        <hr class="my-4">
        <h3 class="text-lg font-semibold text-gray-700 mb-2">Partidas Abiertas (Esperando Oponente):</h3>
        <div id="open-games-list" class="max-h-48 overflow-y-auto border border-gray-200 rounded-md p-2 text-left">
            <p id="no-open-games" class="text-gray-500 text-center">No hay partidas abiertas actualmente.</p>
            <!-- Las partidas se listarán aquí dinámicamente -->
        </div>
    </div>

    <div id="game-section" class="hidden w-full max-w-md flex flex-col items-center">
        <div id="player-turn" class="flex items-center justify-center space-x-4 mb-4 p-3 bg-white rounded-lg shadow">
            <img id="current-player-image" src="" alt="Imagen del jugador actual" class="player-image active">
            <p class="text-lg font-semibold text-gray-700">Turno de: <span id="current-player-name" class="font-bold"></span></p>
        </div>

        <canvas id="tic-tac-toe-canvas" width="306" height="306" class="mb-4 bg-white rounded-lg shadow-inner border-2 border-gray-300"></canvas>

        <div id="status-message-container" class="flex items-center justify-center text-xl font-semibold text-center text-gray-800 mb-4 h-8">
             <span id="status-message"></span>
        </div>

        <div class="flex space-x-4">
             <button id="reset-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200">
                 Reiniciar Partida
             </button>
             <button id="change-players-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200">
                 Nueva Partida / Salir
             </button>
        </div>
    </div>

<script>
    // --- Supabase ---
    const SUPABASE_URL = 'https://gjxhppuobvjuypsxqhah.supabase.co'; // <<<========= REEMPLAZA ESTO
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqeGhwcHVvYnZqdXlwc3hxaGFoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0MzcxNzIsImV4cCI6MjA2MjAxMzE3Mn0.Rk1xe9CCyDccS4ueN-AI6Glv05xSK7hS2LXtxclLXtU'; // <<<===== REEMPLAZA ESTO
    let supabaseClient = null;
    let currentUser = null;
    let currentGameId = null;
    let currentGameData = null;
    let gameRealtimeChannel = null;


    // --- DOM Elements ---
    const authSection = document.getElementById('auth-section');
    const userStatusElement = document.getElementById('user-status');
    const emailInput = document.getElementById('email-input');
    const passwordInput = document.getElementById('password-input');
    const signupButton = document.getElementById('signup-button');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const gameIdInput = document.getElementById('game-id-input');
    const createLoadGameButton = document.getElementById('create-load-game-button');
    const gameLinkMessage = document.getElementById('game-link-message');
    const openGamesListElement = document.getElementById('open-games-list');
    let noOpenGamesMessage = document.getElementById('no-open-games'); 

    const gameSection = document.getElementById('game-section');
    const playerTurnElement = document.getElementById('player-turn');
    const currentPlayerImage = document.getElementById('current-player-image');
    const currentPlayerName = document.getElementById('current-player-name');
    const statusMessageContainer = document.getElementById('status-message-container');
    let statusMessageSpan = document.getElementById('status-message');
    const resetButton = document.getElementById('reset-button');
    const changePlayersButton = document.getElementById('change-players-button');

    // --- Canvas Variables ---
    // ... (sin cambios)
    let canvas = null;
    let ctx = null;
    const CANVAS_WIDTH = 306;
    const CANVAS_HEIGHT = 306;
    const NUM_CELLS_PER_ROW = 3;
    const CELL_SIZE = 100;
    const LINE_THICKNESS = 2;
    const GRID_COLOR = '#e5e7eb';
    const SYMBOL_COLOR_X = '#3b82f6';
    const SYMBOL_COLOR_O = '#ef4444';
    const WINNING_LINE_COLOR = '#10b981';
    const WINNING_LINE_THICKNESS = 5;


    // --- Game State ---
    // ... (sin cambios)
    let board = ['', '', '', '', '', '', '', '', ''];
    let currentPlayerIndex = 0;
    let isGameOver = false;
    const DEFAULT_IMAGE_URL = 'https://placehold.co/60x60/cccccc/ffffff?text=?';
    const winningCombinations = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];


    // --- Supabase Functions ---
    function initializeSupabase() {
        // ... (con log de éxito)
        if (!SUPABASE_URL || SUPABASE_URL === 'TU_SUPABASE_URL' || !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY === 'TU_SUPABASE_ANON_KEY') {
            console.error("Supabase URL o Anon Key no configuradas.");
            alert("Error de configuración: Faltan las credenciales de Supabase.");
            return false;
        }
        try {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log("Supabase client initialized successfully."); 
            return true;
        } catch (error) {
            console.error("Error inicializando Supabase Client:", error);
            alert("Error crítico inicializando Supabase. Revisa la consola.");
            return false;
        }
    }

    async function checkUserSession() {
        console.log("checkUserSession called."); // DEBUG
        if (!supabaseClient) {
            console.error("supabaseClient is null in checkUserSession."); // DEBUG
            return;
        }
        // Guardar el estado anterior de currentUser para detectar cambios
        const previousUserId = currentUser?.id || null;

        const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
        
        if (sessionError) {
            console.error("Error getting session:", sessionError); // DEBUG
            currentUser = null;
        } else if (session) {
            // console.log("Session found for:", session.user.email); // DEBUG - Redundante con el log de AuthStateChange
            currentUser = session.user;
        } else {
            // console.log("No active session found by getSession."); // DEBUG - Redundante con el log de AuthStateChange
            currentUser = null;
        }

        const currentUserId = currentUser?.id || null;
        if (previousUserId !== currentUserId) {
            console.log(`User state CHANGED in checkUserSession. Previous: ${previousUserId}, New: ${currentUserId} (${currentUser?.email})`);
        } else {
            // console.log(`User state UNCHANGED in checkUserSession. User: ${currentUserId} (${currentUser?.email})`);
        }

        if (currentUser) {
            userStatusElement.textContent = `Autenticado: ${currentUser.email.split('@')[0]}`;
            emailInput.classList.add('hidden');
            passwordInput.classList.add('hidden');
            signupButton.classList.add('hidden');
            loginButton.classList.add('hidden');
            logoutButton.classList.remove('hidden');

            if (createLoadGameButton) { 
                createLoadGameButton.disabled = false;
                console.log("User IS authenticated. createLoadGameButton found and ENABLED. Disabled state:", createLoadGameButton.disabled);
            } else {
                console.error("User IS authenticated, BUT createLoadGameButton NOT FOUND to enable it.");
            }
            
            // Solo llamar a fetchAndDisplayOpenGames si el usuario acaba de autenticarse o estamos en la seccion de auth
            if ( (previousUserId === null && currentUser !== null) || !gameSection.classList.contains('hidden') ) { // Corrección: debería ser authSection visible
                 await fetchAndDisplayOpenGames();
            }

        } else { // No hay currentUser
            userStatusElement.textContent = 'No autenticado';
            emailInput.classList.remove('hidden');
            passwordInput.classList.remove('hidden');
            signupButton.classList.remove('hidden');
            loginButton.classList.remove('hidden');
            logoutButton.classList.add('hidden');
            
            if (createLoadGameButton) { 
                createLoadGameButton.disabled = true;
                console.log("User IS NOT authenticated. createLoadGameButton found and DISABLED. Disabled state:", createLoadGameButton.disabled);
            } else {
                console.error("User IS NOT authenticated, AND createLoadGameButton NOT FOUND to disable it.");
            }
            
            openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
            noOpenGamesMessage = document.getElementById('no-open-games');
            if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
            
            if ( (previousUserId !== null && currentUser === null) || gameSection.classList.contains('hidden') === false ) {
                 if (!authSection.classList.contains('hidden') && currentGameId !== null) {
                    // No llamar si ya estamos en auth y no había juego, o si el cambio fue de null a null
                 } else {
                    showAuthSection(); // Muestra la sección de autenticación si el usuario cerró sesión o no estaba ya allí
                 }
            }
        }
    }

    async function handleSignUp() { /* ... (sin cambios) ... */ 
        if (!supabaseClient) return;
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!email || !password) { alert("Email y contraseña son requeridos."); return; }
        const { data, error } = await supabaseClient.auth.signUp({ email, password });
        if (error) alert(`Error registro: ${error.message}`);
        else alert('Registro exitoso. Revisa tu email para confirmar y luego inicia sesión.');
    }

    async function handleSignIn() { /* ... (sin cambios, onAuthStateChange maneja el flujo) ... */
        if (!supabaseClient) return;
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!email || !password) { alert("Email y contraseña son requeridos."); return; }
        const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
        if (error) {
            alert(`Error inicio de sesión: ${error.message}`);
        }
    }

    async function handleSignOut() { /* ... (sin cambios, onAuthStateChange maneja el flujo) ... */
        if (!supabaseClient) return;
        const { error } = await supabaseClient.auth.signOut();
        if (error) {
             alert(`Error cerrando sesión: ${error.message}`);
        }
    }

    async function createNewGameOnSupabase() { /* ... (con logs de depuración) ... */ 
        console.log("createNewGameOnSupabase called."); 
        if (!supabaseClient || !currentUser) {
            console.error("supabaseClient or currentUser is null in createNewGameOnSupabase. SupabaseClient:", supabaseClient, "CurrentUser:", currentUser); 
            return null;
        }
        const initialPlayer = {
            user_id: currentUser.id,
            name: currentUser.email.split('@')[0] || `JugadorX`,
            symbol: 'X',
            imageUrl: DEFAULT_IMAGE_URL
        };
        const newGameData = {
            board: ['', '', '', '', '', '', '', '', ''],
            current_player_index: 0,
            players: [initialPlayer],
            is_game_over: false,
            winner_index: null,
            winning_combination: null,
        };
        console.log("Attempting to insert new game data:", newGameData); 

        const { data, error } = await supabaseClient.from('games').insert([newGameData]).select().single();
        
        if (error) {
            console.error('Error creando partida en Supabase:', error); 
            alert(`Error creando partida: ${error.message} (Revisa tus políticas RLS para la tabla 'games')`); 
            return null;
        }
        console.log("Game created in Supabase, data:", data); 
        return data;
    }


    async function fetchGameFromSupabase(gameId) { /* ... (sin cambios) ... */ 
        if (!supabaseClient) return null;
        const { data, error } = await supabaseClient.from('games').select('*').eq('id', gameId).single();
        if (error) {
            if (error.code !== 'PGRST116') alert(`Error cargando partida: ${error.message}`);
            return null;
        }
        return data;
    }

    async function updateGameOnSupabase(gameId, updates) { /* ... (sin cambios) ... */ 
        if (!supabaseClient || !gameId) return null;
        const { data, error } = await supabaseClient.from('games').update(updates).eq('id', gameId).select().single();
        if (error) { console.error('Error actualizando partida:', error); alert(`Error actualizando: ${error.message}`); return null; }
        return data;
    }

    async function fetchAndDisplayOpenGames() { /* ... (con logs de depuración) ... */ 
        console.log("fetchAndDisplayOpenGames called."); 
        if (!supabaseClient || !currentUser) {
            console.log("Cannot fetch open games, client or user not ready. CurrentUser:", currentUser); 
            openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
            noOpenGamesMessage = document.getElementById('no-open-games');
            if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
            return;
        }

        const { data: games, error } = await supabaseClient
            .from('games')
            .select('id, players, created_at')
            .filter('is_game_over', 'eq', false)
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Error fetching games:', error);
            openGamesListElement.innerHTML = '<p class="text-red-500 text-center">Error al cargar partidas.</p>';
            noOpenGamesMessage = null;
            return;
        }

        const openGames = games.filter(game =>
            game.players &&
            game.players.length === 1 &&
            game.players[0].user_id !== currentUser.id
        );
        console.log("Fetched open games:", openGames.length); 

        openGamesListElement.innerHTML = ''; 

        if (openGames.length === 0) {
            const p = document.createElement('p');
            p.id = 'no-open-games';
            p.className = 'text-gray-500 text-center';
            p.textContent = 'No hay partidas abiertas para unirse.';
            openGamesListElement.appendChild(p);
            noOpenGamesMessage = p;
        } else {
            if (noOpenGamesMessage) noOpenGamesMessage.classList.add('hidden');
            noOpenGamesMessage = null;
            const ul = document.createElement('ul');
            ul.className = 'space-y-2';
            openGames.forEach(game => {
                const li = document.createElement('li');
                li.className = 'p-2 border-b border-gray-100 hover:bg-gray-50 rounded-md flex justify-between items-center cursor-pointer';
                li.onclick = () => {
                    gameIdInput.value = game.id;
                    loadOrCreateGame();
                };

                const gameInfo = document.createElement('span');
                const creatorName = game.players[0]?.name || 'Jugador Anónimo';
                const gameDate = new Date(game.created_at).toLocaleDateString('es-ES', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                gameInfo.textContent = `Partida de ${creatorName} (Creada: ${gameDate})`;
                gameInfo.className = "text-sm text-gray-700";

                const joinButton = document.createElement('button');
                joinButton.textContent = 'Unirse';
                joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white text-xs font-semibold py-1 px-3 rounded-md pointer-events-none';

                li.appendChild(gameInfo);
                li.appendChild(joinButton);
                ul.appendChild(li);
            });
            openGamesListElement.appendChild(ul);
        }
    }

    // --- Canvas Drawing Functions ---
    // ... (sin cambios en estas funciones)
    function initializeCanvasAndBoard() { /* ... */ 
        canvas = document.getElementById('tic-tac-toe-canvas');
        if (!canvas) { console.error("Canvas element not found!"); return false; }
        ctx = canvas.getContext('2d');
        if (!ctx) { console.error("2D context not available!"); return false; }
        
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        drawBoardGrid();
        drawSymbols();
        if (isGameOver && currentGameData && currentGameData.winning_combination) {
            drawWinningLine(currentGameData.winning_combination);
        }
        canvas.removeEventListener('click', handleCanvasClick);
        canvas.addEventListener('click', handleCanvasClick);
        return true;
    }
    function getCellOffset(index) { /* ... */ 
        const row = Math.floor(index / NUM_CELLS_PER_ROW);
        const col = index % NUM_CELLS_PER_ROW;
        const x = col * (CELL_SIZE + LINE_THICKNESS);
        const y = row * (CELL_SIZE + LINE_THICKNESS);
        return { x, y };
    }
    function drawBoardGrid() { /* ... */ 
        if (!ctx) return;
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.strokeStyle = GRID_COLOR;
        ctx.lineWidth = LINE_THICKNESS;

        for (let i = 1; i < NUM_CELLS_PER_ROW; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2, 0);
            ctx.lineTo(i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2, CANVAS_HEIGHT);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2);
            ctx.lineTo(CANVAS_WIDTH, i * CELL_SIZE + (i - 1) * LINE_THICKNESS + LINE_THICKNESS / 2);
            ctx.stroke();
        }
    }
    function drawSymbols() { /* ... */ 
        if (!ctx || !board) return;
        const symbolPadding = CELL_SIZE * 0.2;

        for (let i = 0; i < board.length; i++) {
            const symbol = board[i];
            if (symbol === '') continue;

            const { x: cellX, y: cellY } = getCellOffset(i);
            
            ctx.lineWidth = CELL_SIZE * 0.08;
            ctx.lineCap = 'round';

            if (symbol === 'X') {
                ctx.strokeStyle = SYMBOL_COLOR_X;
                ctx.beginPath();
                ctx.moveTo(cellX + symbolPadding, cellY + symbolPadding);
                ctx.lineTo(cellX + CELL_SIZE - symbolPadding, cellY + CELL_SIZE - symbolPadding);
                ctx.moveTo(cellX + CELL_SIZE - symbolPadding, cellY + symbolPadding);
                ctx.lineTo(cellX + symbolPadding, cellY + CELL_SIZE - symbolPadding);
                ctx.stroke();
            } else if (symbol === 'O') {
                ctx.strokeStyle = SYMBOL_COLOR_O;
                ctx.beginPath();
                ctx.arc(
                    cellX + CELL_SIZE / 2,
                    cellY + CELL_SIZE / 2,
                    CELL_SIZE / 2 - symbolPadding,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
            }
        }
    }
    function drawWinningLine(combination) { /* ... */ 
        if (!ctx || !combination || combination.length !== 3) return;

        const { x: startXOffset, y: startYOffset } = getCellOffset(combination[0]);
        const { x: endXOffset, y: endYOffset } = getCellOffset(combination[2]);
        
        const halfCell = CELL_SIZE / 2;

        ctx.strokeStyle = WINNING_LINE_COLOR;
        ctx.lineWidth = WINNING_LINE_THICKNESS;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(startXOffset + halfCell, startYOffset + halfCell);
        ctx.lineTo(endXOffset + halfCell, endYOffset + halfCell);
        ctx.stroke();
    }

    // --- Realtime Subscription ---
    // ... (sin cambios en estas funciones)
    function subscribeToGameUpdates(gameId) { /* ... */ 
        if (gameRealtimeChannel) {
            gameRealtimeChannel.unsubscribe();
            gameRealtimeChannel = null;
        }
        if (!supabaseClient || !gameId) return;

        console.log(`Subscribing to game updates for game ID: ${gameId}`);
        gameRealtimeChannel = supabaseClient
            .channel(`game-${gameId}`)
            .on(
                'postgres_changes',
                { event: 'UPDATE', schema: 'public', table: 'games', filter: `id=eq.${gameId}` },
                (payload) => {
                    console.log('Game update received via realtime:', payload);
                    const updatedGame = payload.new;
                    if (updatedGame && updatedGame.id === currentGameId) {
                        console.log('Applying real-time update to current game data.');
                        initializeAndDisplayGame(updatedGame);
                    }
                }
            )
            .subscribe((status, err) => {
                if (status === 'SUBSCRIBED') {
                    console.log(`Successfully subscribed to game-${gameId}!`);
                }
                if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                    console.error(`Realtime subscription error on game-${gameId}:`, status, err);
                }
                if (err) {
                    console.error('Realtime subscription failed:', err);
                }
            });
    }
    function unsubscribeFromGameUpdates() { /* ... */ 
        if (gameRealtimeChannel) {
            console.log("Unsubscribing from game updates.");
            supabaseClient.removeChannel(gameRealtimeChannel); 
            gameRealtimeChannel = null;
        }
    }

    // --- Game Logic Functions ---
    // ... (sin cambios en estas funciones, excepto loadOrCreateGame)
    async function initializeAndDisplayGame(gameData) { /* ... */ 
        if (!gameData) {
            alert("No se pudieron obtener los datos de la partida.");
            showAuthSection();
            return;
        }

        currentGameId = gameData.id;
        currentGameData = gameData; 
        board = [...gameData.board];
        currentPlayerIndex = gameData.current_player_index;
        isGameOver = gameData.is_game_over;

        authSection.classList.add('hidden');
        gameSection.classList.remove('hidden');

        statusMessageContainer.innerHTML = '<span id="status-message"></span>';
        statusMessageSpan = document.getElementById('status-message');

        if (!initializeCanvasAndBoard()) return;

        if (isGameOver) {
            displayEndGameMessage();
            unsubscribeFromGameUpdates(); 
        } else {
            updatePlayerTurnDisplay();
            subscribeToGameUpdates(currentGameId); 
        }

        if (currentGameId) {
             gameLinkMessage.textContent = `ID Partida: ${currentGameId}. Comparte este ID o el enlace: ${window.location.origin}${window.location.pathname}?game=${currentGameId}`;
        }
    }
    async function handleCanvasClick(event) { /* ... */ 
        if (isGameOver || !currentGameData || !currentUser || !ctx) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;

        let clickedCol = -1, clickedRow = -1;
        for (let c = 0; c < NUM_CELLS_PER_ROW; c++) {
            const cellStartX = c * (CELL_SIZE + LINE_THICKNESS);
            if (x >= cellStartX && x < cellStartX + CELL_SIZE) {
                clickedCol = c;
                break;
            }
        }
        for (let r = 0; r < NUM_CELLS_PER_ROW; r++) {
            const cellStartY = r * (CELL_SIZE + LINE_THICKNESS);
            if (y >= cellStartY && y < cellStartY + CELL_SIZE) {
                clickedRow = r;
                break;
            }
        }
        
        if (clickedCol === -1 || clickedRow === -1) return;

        const cellIndex = clickedRow * NUM_CELLS_PER_ROW + clickedCol;

        const currentPlayerInGame = currentGameData.players[currentGameData.current_player_index];
        if (!currentPlayerInGame || currentPlayerInGame.user_id !== currentUser.id) {
            alert("No es tu turno o no eres un jugador activo en esta partida.");
            return;
        }
         if (currentGameData.players.length < 2 && currentUser.id !== currentGameData.players[0].user_id) {
             alert("Esperando que se una el segundo jugador o que la partida se actualice.");
             return;
         }


        if (board[cellIndex] !== '') return;

        const symbolToPlace = currentPlayerInGame.symbol;
        board[cellIndex] = symbolToPlace;
        drawSymbols(); 

        let gameEnded = false;
        let newWinnerIndex = null;
        let newWinningCombination = null;

        if (checkWin(symbolToPlace)) {
            isGameOver = true; 
            gameEnded = true;
            newWinnerIndex = currentGameData.current_player_index;
            winningCombinations.forEach(combination => {
                if (combination.every(index => board[index] === symbolToPlace)) {
                    newWinningCombination = combination; 
                }
            });
            if(newWinningCombination) drawWinningLine(newWinningCombination); 
        } else if (board.every(cell => cell !== '')) {
            isGameOver = true; 
            gameEnded = true;
        }

        const nextPlayerIndex = gameEnded ? currentGameData.current_player_index : (1 - currentGameData.current_player_index);

        const updates = {
            board: [...board], 
            current_player_index: nextPlayerIndex,
            is_game_over: isGameOver, 
            winner_index: newWinnerIndex,
            winning_combination: newWinningCombination,
        };

        const updatedGame = await updateGameOnSupabase(currentGameId, updates);
        if (updatedGame) {
            if (!gameRealtimeChannel) { 
                 currentGameData = updatedGame;
                 board = [...updatedGame.board];
                 currentPlayerIndex = updatedGame.current_player_index;
                 isGameOver = updatedGame.is_game_over;

                 if (isGameOver) {
                     displayEndGameMessage();
                 } else {
                     updatePlayerTurnDisplay();
                 }
            }
        } else {
            alert("Error guardando el movimiento. Intentando revertir.");
            board[cellIndex] = ''; 
            isGameOver = false; 
            drawBoardGrid(); 
            drawSymbols();
            updatePlayerTurnDisplay(); 
        }
    }
    function updatePlayerTurnDisplay() { /* ... */ 
        if (!currentGameData || currentGameData.players.length === 0 || isGameOver) {
            playerTurnElement.classList.add('hidden');
            return;
        }
        playerTurnElement.classList.remove('hidden');
        if (currentGameData.current_player_index < 0 || currentGameData.current_player_index >= currentGameData.players.length) {
             console.warn("Índice de jugador actual inválido:", currentGameData.current_player_index, "Jugadores:", currentGameData.players.length);
             if (currentGameData.players.length > 0) {
                currentPlayerIndex = 0; 
             } else {
                currentPlayerName.textContent = "Esperando jugadores...";
                currentPlayerImage.src = DEFAULT_IMAGE_URL;
                return;
             }
        }

        const playerInfo = currentGameData.players[currentPlayerIndex]; 
        if (!playerInfo) {
            currentPlayerName.textContent = "Desconocido";
            currentPlayerImage.src = DEFAULT_IMAGE_URL;
            return;
        }
        currentPlayerName.textContent = playerInfo.name || `Jugador ${playerInfo.symbol}`;
        currentPlayerImage.src = playerInfo.imageUrl || DEFAULT_IMAGE_URL;
        currentPlayerImage.alt = `Imagen de ${playerInfo.name || 'Jugador'}`;
        currentPlayerImage.onerror = function() { this.src = DEFAULT_IMAGE_URL; };
        document.querySelectorAll('.player-image.active').forEach(img => img.classList.remove('active'));
        currentPlayerImage.classList.add('active');
    }
    function displayEndGameMessage() { /* ... */ 
        statusMessageContainer.innerHTML = '';
        statusMessageSpan = document.createElement('span');
        statusMessageContainer.appendChild(statusMessageSpan);

        playerTurnElement.classList.add('hidden');

        if (currentGameData && currentGameData.is_game_over) {
            if (currentGameData.winning_combination) {
                 drawWinningLine(currentGameData.winning_combination);
            }

            if (currentGameData.winner_index !== null && currentGameData.winner_index >=0 && currentGameData.winner_index < currentGameData.players.length && currentGameData.players[currentGameData.winner_index]) {
                const winner = currentGameData.players[currentGameData.winner_index];
                const winnerImg = document.createElement('img');
                winnerImg.src = winner.imageUrl || DEFAULT_IMAGE_URL;
                winnerImg.alt = `Icono de ${winner.name}`;
                winnerImg.classList.add('winner-image');
                statusMessageContainer.insertBefore(winnerImg, statusMessageSpan);
                statusMessageSpan.textContent = `¡${winner.name} (${winner.symbol}) ha ganado!`;
            } else {
                statusMessageSpan.textContent = '¡Es un empate!';
            }
        }
    }
    function checkWin(symbol) { /* ... */ 
        return winningCombinations.some(combination => {
            return combination.every(index => board[index] === symbol);
        });
    }
    async function resetGame() { /* ... */ 
        if (currentGameId) {
            alert("Recargando el estado actual de la partida desde el servidor.");
            const gameData = await fetchGameFromSupabase(currentGameId);
            if (gameData) {
                 initializeAndDisplayGame(gameData); 
            } else {
                alert("No se pudo recargar la partida. Volviendo a la selección.");
                showAuthSection();
            }
        } else {
            showAuthSection();
        }
    }
    function showAuthSection() { /* ... (con log de depuración) ... */ 
        console.log("showAuthSection called."); 
        unsubscribeFromGameUpdates();
        authSection.classList.remove('hidden');
        gameSection.classList.add('hidden');
        gameLinkMessage.textContent = '';
        gameIdInput.value = '';
        currentGameId = null;
        currentGameData = null;
        if (currentUser) { 
            fetchAndDisplayOpenGames();
        } else {
             openGamesListElement.innerHTML = '<p id="no-open-games" class="text-gray-500 text-center">Autentícate para ver partidas.</p>';
             noOpenGamesMessage = document.getElementById('no-open-games');
             if(noOpenGamesMessage) noOpenGamesMessage.classList.remove('hidden');
        }
    }

    async function loadOrCreateGame() { /* ... (con logs de depuración) ... */ 
        console.log("loadOrCreateGame triggered. Game ID input:", `"${gameIdInput.value}"`); 
        if (!currentUser) {
            alert("Debes estar autenticado para crear o unirte a una partida.");
            console.log("currentUser is null, returning from loadOrCreateGame. CurrentUser:", currentUser); 
            return;
        }
        console.log("loadOrCreateGame: currentUser is", currentUser.email); 

        const gameIdToLoad = gameIdInput.value.trim();
        if (gameIdToLoad) {
            console.log("Attempting to load game with ID:", gameIdToLoad); 
            const gameData = await fetchGameFromSupabase(gameIdToLoad);
            if (gameData) {
                console.log("Game data fetched for ID", gameIdToLoad, ":", gameData); 
                if (gameData.is_game_over) {
                    alert("Esta partida ya ha terminado. Mostrando resultado.");
                    initializeAndDisplayGame(gameData);
                    return;
                }
                const isCurrentUserAPlayer = gameData.players.some(p => p.user_id === currentUser.id);

                if (isCurrentUserAPlayer) {
                    console.log("User is already a player in this game. Initializing display."); 
                    initializeAndDisplayGame(gameData);
                } else if (gameData.players.length === 1) {
                    console.log("Game has 1 player, current user is not player. Attempting to join."); 
                    const player2 = {
                        user_id: currentUser.id,
                        name: currentUser.email.split('@')[0] || `JugadorO`,
                        symbol: 'O',
                        imageUrl: DEFAULT_IMAGE_URL
                    };
                    const updatedPlayers = [...gameData.players, player2];
                    const updates = { players: updatedPlayers, current_player_index: gameData.current_player_index };
                    const updatedGame = await updateGameOnSupabase(gameData.id, updates);
                    if (updatedGame) {
                        console.log("Successfully joined game. Initializing display.", updatedGame); 
                        initializeAndDisplayGame(updatedGame);
                    } else {
                        alert("No se pudo unir a la partida como jugador 2.");
                        console.error("Failed to join game as player 2."); 
                    }
                } else if (gameData.players.length >= 2) {
                    alert("Esta partida ya está llena. Puedes verla como espectador.");
                    console.log("Game is full. Initializing display as spectator."); 
                    initializeAndDisplayGame(gameData);
                }
            } else {
                alert(`No se encontró partida con ID: ${gameIdToLoad}. Puedes crear una nueva.`);
                console.log(`Game with ID ${gameIdToLoad} not found.`); 
                gameIdInput.value = '';
            }
        } else { 
            console.log("No game ID provided. Attempting to create a new game..."); 
            const newGame = await createNewGameOnSupabase();
            console.log("createNewGameOnSupabase returned:", newGame); 

            if (newGame) {
                console.log("New game created successfully, initializing display..."); 
                initializeAndDisplayGame(newGame);
                gameIdInput.value = newGame.id; 
                await fetchAndDisplayOpenGames(); 
                console.log("New game display initialized."); 
            } else {
                console.error("Failed to create new game (newGame is null or undefined)."); 
                alert("Hubo un problema al crear la nueva partida. Revisa la consola para más detalles y verifica tus políticas RLS en Supabase.");
            }
        }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded event fired.");
        if (!initializeSupabase()) {
            console.error("Fallo en la inicialización de Supabase. Funcionalidad limitada.");
            return; 
        }
        
        if (signupButton) signupButton.addEventListener('click', handleSignUp);
        if (loginButton) loginButton.addEventListener('click', handleSignIn);
        if (logoutButton) logoutButton.addEventListener('click', handleSignOut);
        
        if (createLoadGameButton) {
            createLoadGameButton.addEventListener('click', loadOrCreateGame);
            console.log("Event listener for createLoadGameButton ADDED.");
        } else {
            console.error("createLoadGameButton NOT FOUND in DOM.");
        }

        if (resetButton) resetButton.addEventListener('click', resetGame);
        if (changePlayersButton) changePlayersButton.addEventListener('click', showAuthSection);

        const urlParams = new URLSearchParams(window.location.search);
        const gameIdFromUrl = urlParams.get('game');
        if (gameIdFromUrl) {
            gameIdInput.value = gameIdFromUrl;
            console.log("Game ID from URL params set in input:", gameIdFromUrl);
        }

        let lastAuthEventUserId = undefined; // Iniciar como undefined para el primer evento

        supabaseClient.auth.onAuthStateChange(async (event, session) => {
            const currentEventUserId = session?.user?.id || null;
            console.log("Auth state changed event:", event, "Session user ID:", currentEventUserId, "Last seen ID by onAuthStateChange:", lastAuthEventUserId);

            if (currentEventUserId !== lastAuthEventUserId || (event === "SIGNED_OUT" && lastAuthEventUserId !== null) || lastAuthEventUserId === undefined) {
                console.log("Auth state change DETECTED as significant. Processing...");
                lastAuthEventUserId = currentEventUserId; 
                
                await checkUserSession(); // Llama a checkUserSession para actualizar la UI y el estado global de currentUser

                if (event === "SIGNED_IN" && session) {
                    const urlParamsOnSign = new URLSearchParams(window.location.search);
                    const gameIdFromUrlOnSignIn = urlParamsOnSign.get('game');
                    // Asegurarse de que el botón esté habilitado antes de intentar cargar el juego
                    if (gameIdFromUrlOnSignIn && !currentGameId && createLoadGameButton && !createLoadGameButton.disabled) {
                        console.log("Attempting to load game from URL after SIGNED_IN:", gameIdFromUrlOnSignIn);
                        await loadOrCreateGame();
                    }
                }
            } else {
                console.log("Auth state change deemed NOT significant (user ID unchanged or redundant event). Skipping full processing by onAuthStateChange.");
            }
        });
        // checkUserSession(); // No es estrictamente necesario aquí, onAuthStateChange se disparará al inicio
                         // pero para asegurar el estado inicial rápido, puede ser útil.
                         // Sin embargo, la lógica de lastAuthEventUserId = undefined manejará el primer disparo.
    });
</script>

</body>
</html>